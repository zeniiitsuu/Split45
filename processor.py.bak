import os
import shutil
import subprocess
import sys
from typing import Callable, List
import math

class MediaProcessor:
    def __init__(self, progress_callback: Callable[[str, float], None] = None, output_folder: str = None):
        self.progress_callback = progress_callback
        self.SEGMENT_LENGTH = 45 * 60  # 45 minutes in seconds
        self.output_folder = output_folder or os.getcwd()
        
        # Define paths for output subfolders
        self.min45_folder = os.path.join(self.output_folder, "45min")
        self.remainder_folder = os.path.join(self.output_folder, "remainder")
        
        # Find bundled FFmpeg binaries
        self.ffmpeg_path = self._find_ffmpeg()
        self.ffprobe_path = self._find_ffprobe()

    def _find_ffmpeg(self):
        """Find FFmpeg executable - bundled or system"""
        # Check if running as exe (PyInstaller)
        if getattr(sys, 'frozen', False):
            # Running as .exe - look for bundled ffmpeg
            base_path = sys._MEIPASS
            ffmpeg_path = os.path.join(base_path, 'ffmpeg', 'ffmpeg.exe')
            if os.path.exists(ffmpeg_path):
                return ffmpeg_path
        else:
            # Running as script - look in local ffmpeg folder first
            local_ffmpeg = os.path.join(os.path.dirname(__file__), 'ffmpeg', 'ffmpeg.exe')
            if os.path.exists(local_ffmpeg):
                return local_ffmpeg
        
        # Fallback to system ffmpeg
        return 'ffmpeg'

    def _find_ffprobe(self):
        """Find FFprobe executable - bundled or system"""
        # Check if running as exe (PyInstaller)
        if getattr(sys, 'frozen', False):
            # Running as .exe - look for bundled ffprobe
            base_path = sys._MEIPASS
            ffprobe_path = os.path.join(base_path, 'ffmpeg', 'ffprobe.exe')
            if os.path.exists(ffprobe_path):
                return ffprobe_path
        else:
            # Running as script - look in local ffmpeg folder first
            local_ffprobe = os.path.join(os.path.dirname(__file__), 'ffmpeg', 'ffprobe.exe')
            if os.path.exists(local_ffprobe):
                return local_ffprobe
        
        # Fallback to system ffprobe
        return 'ffprobe'

    def _create_output_dirs(self):
        os.makedirs(self.min45_folder, exist_ok=True)
        os.makedirs(self.remainder_folder, exist_ok=True)
        print(f"Created output folders: {self.min45_folder}, {self.remainder_folder}")

    def _get_base_name(self, file_path: str) -> str:
        return os.path.splitext(os.path.basename(file_path))[0]

    def _get_output_path(self, base_name: str, part: int, is_full: bool, extension: str) -> str:
        folder = self.min45_folder if is_full else self.remainder_folder
        return os.path.join(folder, f"{base_name} part {part}{extension}")

    def _get_video_duration(self, file_path: str) -> float:
        """Get video duration using ffprobe (much faster than loading with MoviePy)"""
        try:
            cmd = [
                self.ffprobe_path, '-v', 'quiet', '-show_entries', 
                'format=duration', '-of', 'default=noprint_wrappers=1:nokey=1', 
                file_path
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                return float(result.stdout.strip())
            else:
                raise Exception(f"ffprobe failed: {result.stderr}")
        except Exception as e:
            print(f"Error getting duration with ffprobe: {e}")
            return 0

    def _copy_short_video(self, file_path: str, audio_only: bool = False) -> str:
        """Copy or convert short videos to remainder folder"""
        base_name = self._get_base_name(file_path)
        
        if audio_only:
            # Convert to mp3 using ffmpeg (much faster)
            extension = ".mp3"
            output_path = os.path.join(self.remainder_folder, f"{base_name}{extension}")
            
            cmd = [
                self.ffmpeg_path, '-i', file_path, '-acodec', 'mp3', 
                '-ab', '128k', '-y', output_path
            ]
            subprocess.run(cmd, capture_output=True)
        else:
            # Just copy the file
            original_extension = os.path.splitext(file_path)[1]
            output_path = os.path.join(self.remainder_folder, f"{base_name}{original_extension}")
            shutil.copy2(file_path, output_path)
        
        return output_path

    def _split_video_ffmpeg(self, file_path: str, start_time: int, duration: int, output_path: str, audio_only: bool = False):
        """Split video using ffmpeg - MUCH faster than MoviePy"""
        try:
            if audio_only:
                # Extract audio segment
                cmd = [
                    self.ffmpeg_path, '-i', file_path, 
                    '-ss', str(start_time), '-t', str(duration),
                    '-acodec', 'mp3', '-ab', '128k',
                    '-y', output_path
                ]
            else:
                # Extract video segment with stream copy (fastest possible)
                cmd = [
                    self.ffmpeg_path, '-i', file_path,
                    '-ss', str(start_time), '-t', str(duration),
                    '-c', 'copy',  # Stream copy - no re-encoding!
                    '-y', output_path
                ]
            
            print(f"Running: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                print(f"FFmpeg error: {result.stderr}")
                # Fallback to re-encoding if stream copy fails
                if not audio_only and '-c copy' in cmd:
                    print("Stream copy failed, trying with re-encoding...")
                    cmd = [
                        self.ffmpeg_path, '-i', file_path,
                        '-ss', str(start_time), '-t', str(duration),
                        '-c:v', 'libx264', '-preset', 'ultrafast',
                        '-c:a', 'aac', '-b:a', '128k',
                        '-y', output_path
                    ]
                    result = subprocess.run(cmd, capture_output=True, text=True)
            
            return result.returncode == 0
            
        except Exception as e:
            print(f"Error splitting with ffmpeg: {e}")
            return False

    def _delete_original_file(self, file_path: str):
        """Safely delete the original file after successful processing"""
        try:
            if os.path.exists(file_path):
                os.remove(file_path)
                print(f"ğŸ—‘ï¸ Deleted original file: {os.path.basename(file_path)}")
                return True
        except Exception as e:
            print(f"âš ï¸ Could not delete original file {file_path}: {e}")
            return False

    def process_video(self, file_path: str, audio_only: bool = False, delete_original: bool = True) -> List[str]:
        self._create_output_dirs()
        output_files = []
        processing_successful = False
        
        try:
            print(f"Processing: {os.path.basename(file_path)}")
            print(f"Using FFmpeg: {self.ffmpeg_path}")
            print(f"Output folder: {self.output_folder}")
            
            # Get duration using ffprobe (much faster than loading video)
            if self.progress_callback:
                self.progress_callback("Getting video duration...", 10)
            
            duration = self._get_video_duration(file_path)
            if duration <= 0:
                print("Could not get video duration")
                return []
            
            print(f"Duration: {duration/60:.1f} minutes")

            # If video is shorter than or equal to 45 minutes, just copy it
            if duration <= self.SEGMENT_LENGTH:
                print("Video is short - copying to remainder folder")
                
                if self.progress_callback:
                    self.progress_callback("Copying short video to remainder folder...", 50)
                
                output_path = self._copy_short_video(file_path, audio_only)
                
                # Check if copy/conversion was successful
                if os.path.exists(output_path):
                    output_files.append(output_path)
                    processing_successful = True
                    
                    if self.progress_callback:
                        self.progress_callback("Short video copied successfully!", 100)
                    
                    print(f"Completed: {output_path}")
                else:
                    print("Failed to copy/convert short video")
                    return []

            else:
                # Split video using ffmpeg
                print("Video is long - splitting with FFmpeg (much faster!)")
                num_segments = math.ceil(duration / self.SEGMENT_LENGTH)
                base_name = self._get_base_name(file_path)
                extension = ".mp3" if audio_only else ".mp4"
                successful_segments = 0

                for i in range(num_segments):
                    start_time = i * self.SEGMENT_LENGTH
                    segment_duration = min(self.SEGMENT_LENGTH, duration - start_time)
                    is_full = abs(segment_duration - self.SEGMENT_LENGTH) < 1

                    print(f"Creating segment {i+1}/{num_segments} ({start_time/60:.1f}-{(start_time+segment_duration)/60:.1f} min)")
                    
                    if self.progress_callback:
                        self.progress_callback(f"FFmpeg processing segment {i+1}/{num_segments} - Much faster than before!", 
                                             (i / num_segments) * 100)
                    
                    output_path = self._get_output_path(base_name, i + 1, is_full, extension)
                    
                    print(f"Writing segment to: {output_path}")
                    print("Using FFmpeg - this should be much faster!")
                    
                    success = self._split_video_ffmpeg(file_path, int(start_time), int(segment_duration), output_path, audio_only)
                    
                    if success and os.path.exists(output_path):
                        output_files.append(output_path)
                        successful_segments += 1
                        print(f"Completed segment {i+1}/{num_segments} in seconds (not minutes!)")
                    else:
                        print(f"Failed to create segment {i+1}")

                    if self.progress_callback:
                        progress = ((i + 1) / num_segments) * 100
                        self.progress_callback(f"FFmpeg completed segment {i+1}/{num_segments}", progress)

                # Consider processing successful if all segments were created
                processing_successful = (successful_segments == num_segments)
                
                if processing_successful:
                    print(f"Completed splitting into {num_segments} segments with FFmpeg!")
                    if self.progress_callback:
                        self.progress_callback("All segments completed with FFmpeg!", 100)
                else:
                    print(f"Only {successful_segments}/{num_segments} segments were successful")

            # Delete original file if processing was successful and delete_original is True
            if processing_successful and delete_original:
                print(f"Processing successful! Cleaning up original file...")
                if self.progress_callback:
                    self.progress_callback("Cleaning up original file...", 100)
                
                self._delete_original_file(file_path)
                
            return output_files

        except Exception as e:
            print(f"Error processing {file_path}: {str(e)}")
            if self.progress_callback:
                self.progress_callback(f"Error: {str(e)}", -1)
            return []

    def process_files(self, file_paths: List[str], audio_only: bool = False, delete_originals: bool = True) -> List[str]:
        all_output_files = []
        total_files = len(file_paths)
        successful_files = 0
        
        print(f"\n=== Starting batch processing in output folder: {self.output_folder} ===")
        
        media_type = "audio files" if audio_only else "videos"
        if self.progress_callback:
            self.progress_callback(f"Starting processing of {total_files} {media_type}...", 0)
        
        for idx, file_path in enumerate(file_paths):
            file_num = idx + 1
            print(f"\n=== Processing file {file_num}/{total_files} with FFmpeg ===")
            
            if self.progress_callback:
                filename = os.path.basename(file_path)
                self.progress_callback(f"Processing {media_type[:-1]} {file_num}/{total_files}: {filename}", 0)
            
            output_files = self.process_video(file_path, audio_only, delete_originals)
            
            if output_files:
                all_output_files.extend(output_files)
                successful_files += 1
                
                if self.progress_callback:
                    filename = os.path.basename(file_path)
                    segments_created = len(output_files)
                    self.progress_callback(f"âœ… Completed {file_num}/{total_files}: {filename} ({segments_created} segments)", 100)
            else:
                if self.progress_callback:
                    filename = os.path.basename(file_path)
                    self.progress_callback(f"âŒ Failed {file_num}/{total_files}: {filename}", -1)
            
        # Final status message
        if self.progress_callback:
            total_segments = len(all_output_files)
            if successful_files == total_files:
                self.progress_callback(f"ğŸ‰ All {successful_files} {media_type} processed successfully! Created {total_segments} segments.", 100)
            elif successful_files > 0:
                self.progress_callback(f"âœ… Processed {successful_files}/{total_files} {media_type}. Created {total_segments} segments.", 100)
            else:
                self.progress_callback(f"âŒ No {media_type} processed successfully", -1)
            
        if delete_originals and successful_files > 0:
            print(f"\nğŸ§¹ Cleanup completed! Original files have been removed to save space.")
            
        print(f"\nğŸ“ All files processed and saved to: {self.output_folder}")
        print(f"   ğŸ“‚ 45-minute segments: {self.min45_folder}")
        print(f"   ğŸ“‚ Shorter segments: {self.remainder_folder}")
        print(f"   ğŸ¯ Total segments created: {len(all_output_files)}")
            
        return all_output_files 